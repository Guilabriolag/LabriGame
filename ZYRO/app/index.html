<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ZYRO v0.3 - Mapa Infinito</title>
    <style>
        /* (SEU CSS ORIGINAL - SEM ALTERA√á√ïES) */
        body {
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background: #222;
            touch-action: none;
            font-family: 'Orbitron', Arial, sans-serif;
        }

        canvas {
            display: block;
            background: #4caf50;
        }

        #hud {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 10px;
            color: white;
            font: bold 14px Arial;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 10px;
            border: 2px solid #00bfff;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.3);
            z-index: 100;
        }

        #survival-hud {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #00bfff;
            font: 12px Arial;
            z-index: 100;
        }

        .survival-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 3px 0;
            overflow: hidden;
        }

        .survival-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .hunger { background: linear-gradient(90deg, #ff6b35, #f7931e);
        }
        .thirst { background: linear-gradient(90deg, #4fc3f7, #29b6f6);
        }
        .oxygen { background: linear-gradient(90deg, #66bb6a, #43a047);
        }
        .energy { background: linear-gradient(90deg, #ffa726, #ff9800);
        }

        #joystick {
            position: absolute;
            bottom: calc(80px + env(safe-area-inset-bottom, 0));
            left: 30px;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.3), rgba(0, 191, 255, 0.1));
            border: 3px solid rgba(0, 191, 255, 0.6);
            border-radius: 50%;
            touch-action: none;
        }

        #stick {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #00bfff, #0080ff);
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.6);
        }

        .button {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: white;
            font: bold 18px Arial;
            text-align: center;
            line-height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid;
            touch-action: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .button:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px;
        }

        #buttonA {
            bottom: calc(80px + env(safe-area-inset-bottom, 0));
            right: 140px;
            background: linear-gradient(135deg, #dc2626, #991b1b);
            border-color: #ef4444;
        }

        #buttonB {
            bottom: calc(150px + env(safe-area-inset-bottom, 0));
            right: 70px;
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            border-color: #3b82f6;
        }

        #buttonC {
            bottom: calc(80px + env(safe-area-inset-bottom, 0));
            right: 70px;
            background: linear-gradient(135deg, #16a34a, #15803d);
            border-color: #22c55e;
        }

        #buttonD {
            bottom: calc(150px + env(safe-area-inset-bottom, 0));
            right: 140px;
            background: linear-gradient(135deg, #ea580c, #c2410c);
            border-color: #f97316;
        }

        .interface-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: white;
            display: none;
            z-index: 1000;
            overflow-y: auto;
        }

        .interface-header {
            background: linear-gradient(90deg, #0ea5e9, #0284c7);
            padding: 15px;
            text-align: center;
            font: bold 18px Arial;
            border-bottom: 3px solid #00bfff;
        }

        .interface-content {
            padding: 20px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00bfff;
        }

        .status-card h3 {
            margin: 0 0 10px 0;
            color: #00bfff;
            font-size: 14px;
        }

        .equipment-slot {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #666;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .equipment-slot.equipped {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin: 15px 0;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
        }

        .inventory-slot.filled {
            border-color: #00bfff;
            background: rgba(0, 191, 255, 0.2);
        }

        .action-button {
            background: linear-gradient(135deg, #00bfff, #0080ff);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font: bold 14px Arial;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #dc2626;
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font: bold 20px Arial;
            cursor: pointer;
        }

        #farming-interface {
            background: linear-gradient(135deg, #166534, #15803d);
        }

        .farming-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .farming-plot {
            aspect-ratio: 1;
            background: #8b4513;
            border: 3px solid #654321;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            position: relative;
        }

        .farming-plot.planted {
            background: #228b22;
            border-color: #32cd32;
        }

        .farming-plot.ready {
            background: #ffd700;
            border-color: #ffff00;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px #ffff00;
            }
            to { box-shadow: 0 0 20px #ffff00;
            }
        }

        @keyframes fadeMessage {
            0% { opacity: 0;
            transform: translateX(-50%) translateY(-20px); }
            20%, 80% { opacity: 1;
            transform: translateX(-50%) translateY(0); }
            100% { opacity: 0;
            transform: translateX(-50%) translateY(-20px); }
        }
    </style>
</head>
<body>
    <div id="hud">√Årea: Plan√≠cie ZYRO (0, 0)</div>
    <div id="survival-hud">
        <div>üçñ Fome: <div class="survival-bar"><div class="survival-fill hunger" style="width: 80%"></div></div></div>
        <div>üíß Sede: <div class="survival-bar"><div class="survival-fill thirst" style="width: 60%"></div></div></div>
        <div>ü´Å O¬≤: <div class="survival-bar"><div class="survival-fill oxygen" style="width: 90%"></div></div></div>
        <div>‚ö° Energia: <div class="survival-bar"><div class="survival-fill energy" style="width: 70%"></div></div></div>
    </div>

    <div id="joystick"><div id="stick"></div></div>
   
    <div id="buttonA" class="button">A</div>
    <div id="buttonB" class="button">B</div>
    <div id="buttonC" class="button">C</div>
    <div id="buttonD" class="button">D</div>

    <div id="ship-interface" class="interface-panel">
        <button class="close-button" onclick="closeInterface('ship-interface')">&times;</button>
        <div class="interface-header">üöÄ NAVE DANIFICADA - SISTEMA DE MANUTEN√á√ÉO</div>
        <div class="interface-content">
            <div class="status-grid">
                <div class="status-card">
 
                    <h3>üìä Status Vital</h3>
                    <div>Fome: <span id="hunger-text">80%</span></div>
                    <div>Sede: <span id="thirst-text">60%</span></div>
                    <div>Oxig√™nio: <span id="oxygen-text">90%</span></div>
             
                    <div>Energia: <span id="energy-text">70%</span></div>
                </div>
                <div class="status-card">
                    <h3>üéí Equipamentos</h3>
                    <div class="equipment-slot" id="backpack-slot" onclick="equipBackpack()">
              
                    <div>Mochila: Nenhuma</div>
                        <div style="font-size: 12px;">Clique para equipar</div>
                    </div>
                </div>
            </div>
            
 
            <div class="status-card">
                <h3>üì¶ Invent√°rio (<span id="inv-count">0</span>/<span id="inv-max">10</span>)</h3>
                <div class="inventory-grid" id="ship-inventory"></div>
            </div>
            
            <div style="text-align: center;
            margin-top: 20px;">
                <button class="action-button" onclick="consumeItem('food')">üçñ Comer</button>
                <button class="action-button" onclick="consumeItem('water')">üíß Beber</button>
                <button class="action-button" onclick="rest()">üò¥ Descansar</button>
            </div>
        </div>
    </div>

    <div id="bunker-interface" class="interface-panel" style="background: linear-gradient(135deg, #166534, 
    #15803d);">
        <button class="close-button" onclick="closeInterface('bunker-interface')">&times;</button>
        <div class="interface-header">üè† BUNKER AGR√çCOLA - SISTEMA DE CULTIVO</div>
        <div class="interface-content">
            <div class="status-card">
                <h3>üå± Planta√ß√£o Hidrop√¥nica</h3>
                <div class="farming-grid" id="farming-plots"></div>
            </div>
     
        
            <div style="text-align: center;
            margin-top: 20px;">
                <button class="action-button" onclick="plantCrop('potato')">ü•î Plantar Batata</button>
                <button class="action-button" onclick="plantCrop('oxygen-plant')">üåø Plantar O¬≤ Plant</button>
                <button class="action-button" onclick="waterPlants()">üíß Regar Plantas</button>
                <button class="action-button" onclick="harvestAll()">üåæ Colher Tudo</button>
            </div>
      
       
            <div class="status-card" style="margin-top: 20px;">
                <h3>üìä Recursos Dispon√≠veis</h3>
                <div>üíß √Ågua: <span id="water-count">0</span></div>
                <div>ü•î Sementes de Batata: <span id="potato-seeds">0</span></div>
                <div>üåø Mudas de O¬≤: <span 
                id="oxygen-seeds">0</span></div>
            </div>
        </div>
    </div>

    <div id="workshop-interface" class="interface-panel">
        <button class="close-button" onclick="closeInterface('workshop-interface')">&times;</button>
        <div class="interface-header">üîß OFICINA DE CONSTRU√á√ÉO</div>
        <div class="interface-content" style="text-align:center;">
            <div class="status-card">
                <h3>üõ†Ô∏è 
                Receitas Dispon√≠veis</h3>
                <p>üíä Kit M√©dico: 1 √Ågua + 1 Batata</p>
                <p>üåø Filtro de O¬≤: 1 Planta + 1 √Ågua</p>
                <p>‚ö° Painel Solar: Requer Mochila</p>
            </div>
            <button class="action-button" onclick="craftItem('medkit')">üíä Criar Kit M√©dico</button>
   
            <button class="action-button" onclick="craftItem('filter')">üåø Criar Filtro de O¬≤</button>
            <button class="action-button" onclick="craftItem('solar')">‚ö° Montar Painel Solar</button>
        </div>
    </div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- SISTEMA DE MAPA INFINITO E BIOMAS ---
        const CHUNK_SIZE = 1200; // Tamanho de cada bloco de mapa (Chunk)

        // Defini√ß√£o dos Biomas
        const BIOMES = {
            'zyro_plains': {
                name: "Plan√≠cie ZYRO",
                backgroundGradient: ["#4a5568", "#2d3748"],
                poiDensity: 4, // Densidade de POIs (Recursos)
                enemyDensity: 2, // Densidade de Inimigos
            },
            'lava_wasteland': {
                name: "Ermo de Lava",
                backgroundGradient: ["#ff5722", "#d84315"],
                poiDensity: 1, 
                enemyDensity: 5,
            },
            'ice_tundra': {
                name: "Tundra Congelada",
                backgroundGradient: ["#b3e5fc", "#81d4fa"],
                poiDensity: 3,
                enemyDensity: 1,
            }
        };

        // Tipos de Pontos de Interesse Ger√°veis
        const GENERATED_POIS = [
            { type: "water", name: "Mina de √Ågua", icon: "üíß", color: "#4fc3f7" },
            { type: "oxygen", name: "Ponto de O¬≤", icon: "üåø", color: "#66bb6a" },
            { type: "equipment", name: "Equipamentos", icon: "üéí", color: "#ffa726" },
        ];

        // Pontos de Interesse Fixos (Apenas no chunk inicial 0,0)
        const BASE_POIS = [
            {x: 600, y: 400, type: "ship", name: "Nave Danificada", icon: "üöÄ", color: "#ff6b35"},
            {x: 200, y: 600, type: "bunker", name: "Bunker Agr√≠cola", icon: "üè†", color: "#8b4513"},
            {x: 600, y: 700, type: "workshop", name: "Oficina", icon: "üîß", color: "#9ca3af"}
        ];

        let currentChunkData = {
            biome: BIOMES.zyro_plains,
            pointsOfInterest: BASE_POIS,
            enemies: [], 
        };
        // --- FIM SISTEMA DE MAPA INFINITO ---

        // Player e sistema de sobreviv√™ncia
        let player = {
            x: 600, // Posi√ß√£o dentro do chunk (0 a CHUNK_SIZE)
            y: 400,
            r: 25,
            speed: 4,
            inventory: [],
            maxInventory: 10,
            backpack: null,
            hunger: 80,
            thirst: 60,
            oxygen: 90,
            energy: 70,
            health: 100,
            chunkX: 0, // Coordenada X do chunk atual
            chunkY: 0  // Coordenada Y do chunk atual
        };
        // Recursos e equipamentos
        let gameState = {
            water: 0,
            potatoSeeds: 2,
            oxygenSeeds: 1,
            farmingPlots: Array(16).fill(null),
            lastSurvivalUpdate: Date.now()
        };
        // Sistema de Miss√µes
        let missions = [
            { id: 1, text: "Explore a Mina de √Ågua üíß", completed: false },
            { id: 2, text: "Colete 5 unidades de √Ågua üíß", completed: false },
            { id: 3, text: "Plante e colha uma Batata ü•î", completed: false },
            { id: 
            4, text: "Equipe uma Mochila üéí", completed: false },
            { id: 5, text: "Repare o M√≥dulo da Nave ‚ö°", completed: false }
        ];

        // POIs e Inimigos agora s√£o carregados pelo chunk
        let pointsOfInterest = []; 
        let enemies = [];

        // Exibir painel lateral
        const missionPanel = document.createElement("div");
        missionPanel.id = "mission-panel";
        missionPanel.style.cssText = `
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            border: 2px solid #00bfff;
            color: white;
            font: 12px Arial;
            border-radius: 10px;
            padding: 10px;
            z-index: 200;
            width: 220px;
        `;
        document.body.appendChild(missionPanel);

        function updateMissions() {
            missionPanel.innerHTML = "<b>üìú Miss√µes</b><br>";
            let completedCount = 0;
            missions.forEach(m => {
                if (m.completed) completedCount++;
                missionPanel.innerHTML += (m.completed ? "‚úÖ " : "üî∏ ") + m.text + "<br>";
            });
            missionPanel.innerHTML += `<hr>Progresso: ${completedCount}/${missions.length}`;
        }
        
        // --- FUN√á√ïES DE GERA√á√ÉO DE CHUNK ---

        // Fun√ß√£o de hash simples e est√°vel (para que o chunk seja o mesmo toda vez)
        function simpleRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateChunk(chunkX, chunkY) {
            const seed = (chunkX * 1000 + chunkY) * 100 + 12345;
            const rng = simpleRandom(seed);
            const biomeKeys = Object.keys(BIOMES);
            let selectedBiome;

            // Chunk inicial (0,0) √© sempre a Plan√≠cie ZYRO
            if (chunkX === 0 && chunkY === 0) {
                selectedBiome = BIOMES.zyro_plains;
            } else {
                // Sele√ß√£o procedural de bioma (exclui o bioma inicial)
                const index = Math.floor(rng * (biomeKeys.length - 1)) + 1;
                selectedBiome = BIOMES[biomeKeys[index]];
            }

            let pois = [];
            // Adiciona POIs fixos apenas no chunk inicial
            if (chunkX === 0 && chunkY === 0) {
                pois = [...BASE_POIS]; 
            }

            // Gera√ß√£o de POIs aleat√≥rios
            const numPOIs = Math.floor(selectedBiome.poiDensity * simpleRandom(seed + 1) * 0.8 + 1);
            for (let i = 0; i < numPOIs; i++) {
                const poiType = GENERATED_POIS[Math.floor(simpleRandom(seed + 2 + i) * GENERATED_POIS.length)];
                pois.push({
                    x: Math.floor(simpleRandom(seed + 3 + i) * (CHUNK_SIZE - 200)) + 100,
                    y: Math.floor(simpleRandom(seed + 4 + i) * (CHUNK_SIZE - 200)) + 100,
                    type: poiType.type,
                    name: poiType.name,
                    icon: poiType.icon,
                    color: poiType.color,
                });
            }

            // Gera√ß√£o de Inimigos
            let newEnemies = [];
            const numEnemies = Math.floor(selectedBiome.enemyDensity * simpleRandom(seed + 5) * 0.8 + 1);
            for (let i = 0; i < numEnemies; i++) {
                newEnemies.push({
                    x: Math.floor(simpleRandom(seed + 6 + i) * (CHUNK_SIZE - 200)) + 100,
                    y: Math.floor(simpleRandom(seed + 7 + i) * (CHUNK_SIZE - 200)) + 100,
                    hp: 30, maxHp: 30, active: true, lastAttack: 0
                });
            }

            return {
                biome: selectedBiome,
                pointsOfInterest: pois,
                enemies: newEnemies
            };
        }

        function loadChunk(chunkX, chunkY) {
            const newChunk = generateChunk(chunkX, chunkY);
            currentChunkData = newChunk;
            
            // Atualiza as listas globais de POIs e Inimigos para o render/intera√ß√£o
            pointsOfInterest = newChunk.pointsOfInterest; 
            enemies = newChunk.enemies;
            
            document.getElementById("hud").textContent = `√Årea: ${newChunk.biome.name} (${chunkX}, ${chunkY})`;
            showMessage(`Explorando novo bioma: ${newChunk.biome.name}!`);
        }

        // --- FUN√á√ïES DE GAMEPLAY (ORIGINAIS) ---

        function drawEnemies() {
            // (SEU C√ìDIGO ORIGINAL - FUNCIONA POIS ITERA SOBRE A LISTA ATUALIZADA)
            enemies.forEach(e => {
                if (!e.active) return;
                
                // Seguir o jogador
                const dx = player.x - e.x;
          
                const dy = player.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 200) {
                    e.x += dx / dist * 0.5;
      
                    e.y += dy / dist * 0.5;
                    
                    // Atacar se pr√≥ximo
                    if (dist < 50 && Date.now() - e.lastAttack > 2000) {
       
                        player.health = Math.max(0, player.health - 10);
                        e.lastAttack = Date.now();
                        showMessage("üëæ Criatura alien√≠gena atacou!");
                        if 
                        (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                    }
                }
                
                // Desenhar alien
                ctx.fillStyle = "#8b0000";
         
                ctx.beginPath();
                ctx.arc(e.x, e.y, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#ff0000";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Barra de HP
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(e.x - 25, e.y - 35, 50, 8);
                ctx.fillStyle = "#ff0000";
                ctx.fillRect(e.x - 23, e.y - 33, (e.hp / e.maxHp) * 46, 4);
                // Olhos amarelos
                ctx.fillStyle = "#ffff00";
                ctx.beginPath();
                ctx.arc(e.x - 8, e.y - 5, 3, 0, Math.PI * 2);
                ctx.arc(e.x + 8, e.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // C√¢mera
        let cam = { x: 0, y: 0 };
        // Ciclo de Dia e Noite
        let timeOfDay = 12;
        // 0‚Äì24

        function updateDayCycle() {
            timeOfDay = (timeOfDay + 0.01) % 24;
            const isNight = timeOfDay >= 18 || timeOfDay < 6;
            // Ajustar brilho
            const brightness = isNight ?
            0.6 : 1;
            canvas.style.filter = `brightness(${brightness})`;
            
            // Efeitos noturnos
            if (isNight && Math.random() < 0.001) {
                showMessage("üåí A noite cai... o frio aumenta.");
                player.energy = Math.max(0, player.energy - 2);
            }
        }

        // Controles do joystick
        const joystick = document.getElementById("joystick");
        const stick = document.getElementById("stick");
        let joy = { active: false, x: 0, y: 0 };
        
        // CORRE√á√ÉO: Usar touchstart/touchend com passive: false para o joystick
        joystick.addEventListener("touchstart", handleJoystickStart, { passive: false });
        joystick.addEventListener("touchend", handleJoystickEnd);
        joystick.addEventListener("touchmove", handleJoystickMove, { passive: false });

        // Fun√ß√£o de In√≠cio do Joystick
        function handleJoystickStart(e) {
            e.preventDefault();
            joy.active = true;
            if (navigator.vibrate) navigator.vibrate(10);
            if (e.touches) handleJoystickMove(e); // Captura o movimento inicial
        }

        // Fun√ß√£o de Fim do Joystick
        function handleJoystickEnd(e) {
            e.preventDefault();
            joy.active = false;
            stick.style.left = "50%";
            stick.style.top = "50%";
            joy.x = 0;
            joy.y = 0;
        }

        // Fun√ß√£o de Movimento do Joystick
        function handleJoystickMove(e) {
            e.preventDefault();
            if (!joy.active) return;
            
            // Usa o primeiro toque para mobile
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = joystick.getBoundingClientRect();
            let dx = clientX - (rect.left + rect.width / 2);
            let dy = clientY - (rect.top + rect.height / 2);
            const dist = Math.min(Math.sqrt(dx * dx + dy * dy), rect.width / 2);
            const angle = Math.atan2(dy, dx);
            
            stick.style.left = rect.width / 2 + dist * Math.cos(angle) + "px";
            stick.style.top 
            = rect.height / 2 + dist * Math.sin(angle) + "px";
            joy.x = Math.cos(angle) * (dist / (rect.width / 2));
            joy.y = Math.sin(angle) * (dist / (rect.width / 2));
        }

        // Fun√ß√£o de ataque
        function attackNearestEnemy() {
            const nearest = enemies.find(e => e.active && Math.hypot(player.x - e.x, player.y - e.y) < 100);
            if (nearest) {
                nearest.hp -= 15;
                showMessage("üí• Ataque alien√≠gena!");
                if (navigator.vibrate) navigator.vibrate(30);
                if (nearest.hp <= 0) {
                    nearest.active = false;
                    showMessage("üëæ Inimigo derrotado! +1 recurso raro");
                    if (player.inventory.length < player.maxInventory) {
                        player.inventory.push("üíé");
                    }
                }
                return true;
            }
            return false;
        }

        // Bot√µes de a√ß√£o (Corrigido para usar touchstart)
        document.getElementById("buttonA").addEventListener("touchstart", e => {
            e.preventDefault();
            if (navigator.vibrate) navigator.vibrate(20);
            if (!attackNearestEnemy()) {
                interactWithNearestPOI();
            }
        });
        document.getElementById("buttonB").addEventListener("touchstart", e => {
            e.preventDefault();
            if (navigator.vibrate) navigator.vibrate(15);
            showMessage("üì¶ Invent√°rio: " + player.inventory.length + "/" + player.maxInventory);
        });
        document.getElementById("buttonC").addEventListener("touchstart", e => {
            e.preventDefault();
            if (navigator.vibrate) navigator.vibrate(15);
            showMessage("üó∫Ô∏è Mapa: NaveüöÄ √Åguaüíß O¬≤üåø Bunkerüè† Equipüéí Oficinaüîß");
        });
        document.getElementById("buttonD").addEventListener("touchstart", e => {
            e.preventDefault();
            if (navigator.vibrate) navigator.vibrate([10, 50, 10]);
            scanArea();
        });
        // Fun√ß√µes de intera√ß√£o
        function interactWithNearestPOI() {
            let nearestPOI = null;
            let minDistance = Infinity;
            
            pointsOfInterest.forEach(poi => {
                let dx = player.x - poi.x;
                let dy = player.y - poi.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
           
                if (distance < 80 && distance < minDistance) {
                    minDistance = distance;
                    nearestPOI = poi;
                }
            });
            if (nearestPOI) {
                handlePOIInteraction(nearestPOI);
            } else {
                showMessage("‚ùå Nenhum ponto de interesse pr√≥ximo");
            }
        }
        
        // (RESTANTE DO SEU C√ìDIGO JS ORIGINAL V0.2)

        function handlePOIInteraction(poi) {
            switch(poi.type) {
                case "ship":
                    if (player.chunkX !== 0 || player.chunkY !== 0) {
                        showMessage("‚ùå A nave est√° no chunk inicial (0, 0)!");
                        return;
                    }
                    document.getElementById("ship-interface").style.display = "block";
                    updateShipInterface();
                    break;
                    
                case "water":
                    if (player.inventory.length < player.maxInventory) {
                        gameState.water += 3;
                        player.inventory.push("üíß");
                        showMessage("üíß Coletou 3 unidades de √°gua!");
                        missions[0].completed = true;
                        // Explorou a mina
                        if (gameState.water >= 5) missions[1].completed = true;
                        // Coletou 5 √°guas
                        updateMissions();
                        if (navigator.vibrate) navigator.vibrate(30);
                    } else {
                        showMessage("‚ùå Invent√°rio cheio!");
                    }
                    break;
                case "oxygen":
                    if (player.inventory.length < player.maxInventory) {
                        gameState.oxygenSeeds += 2;
                        player.inventory.push("üåø");
                        player.oxygen = Math.min(100, player.oxygen + 20);
                        showMessage("üåø Coletou mudas de O¬≤ e respirou ar puro!");
                        if (navigator.vibrate) navigator.vibrate(30);
                    } else {
                        showMessage("‚ùå Invent√°rio cheio!");
                    }
                    break;
                case "bunker":
                    if (player.chunkX !== 0 || player.chunkY !== 0) {
                        showMessage("‚ùå O bunker est√° no chunk inicial (0, 0)!");
                        return;
                    }
                    document.getElementById("bunker-interface").style.display = "block";
                    updateBunkerInterface();
                    break;
                    
                case "equipment":
                    if (!player.backpack && player.inventory.length < player.maxInventory) {
                        player.inventory.push("üéí");
                        showMessage("üéí Encontrou uma mochila! Use na nave para equipar.");
                        if (navigator.vibrate) navigator.vibrate(30);
                    } else if (player.backpack) {
                        showMessage("‚úÖ Voc√™ j√° tem uma mochila equipada!");
                    } else {
                        showMessage("‚ùå Invent√°rio cheio!");
                    }
                    break;
                case "workshop":
                    if (player.chunkX !== 0 || player.chunkY !== 0) {
                        showMessage("‚ùå A oficina est√° no chunk inicial (0, 0)!");
                        return;
                    }
                    document.getElementById("workshop-interface").style.display = "block";
                    break;
            }
        }

        function scanArea() {
            let nearbyPOIs = [];
            let nearbyEnemies = 0;
            
            pointsOfInterest.forEach(poi => {
                let dx = player.x - poi.x;
                let dy = player.y - poi.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
           
                if (distance < 200) {
                    nearbyPOIs.push(poi.name);
                }
            });
            enemies.forEach(e => {
                if (e.active) {
                    let dx = player.x - e.x;
                    let dy = player.y - e.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
 
                    
                    if (distance < 200) {
                        nearbyEnemies++;
                    }
             
                }
            });
            let message = `üîç ${currentChunkData.biome.name} (${player.chunkX}, ${player.chunkY}) - Detectado: `;
            if (nearbyPOIs.length > 0) {
                message += nearbyPOIs.join(", ");
            }
            if (nearbyEnemies > 0) {
                message += (nearbyPOIs.length > 0 ? ", " : "") + `${nearbyEnemies} inimigo(s)`;
            }
            if (nearbyPOIs.length === 0 && nearbyEnemies === 0) {
                message = "üîç Nenhum ponto de interesse detectado";
            }
            
            showMessage(message);
        }

        // Fun√ß√µes da interface da nave
        function updateShipInterface() {
            document.getElementById("hunger-text").textContent = Math.round(player.hunger) + "%";
            document.getElementById("thirst-text").textContent = Math.round(player.thirst) + "%";
            document.getElementById("oxygen-text").textContent = Math.round(player.oxygen) + "%";
            document.getElementById("energy-text").textContent = Math.round(player.energy) + "%";
            document.getElementById("inv-count").textContent = player.inventory.length;
            document.getElementById("inv-max").textContent = player.maxInventory;
            
            // Atualizar slot da mochila
            const backpackSlot = document.getElementById("backpack-slot");
            if (player.backpack) {
                backpackSlot.className = "equipment-slot equipped";
                backpackSlot.innerHTML = "<div>Mochila: Equipada ‚úÖ</div><div style='font-size: 12px;'>+5 slots de invent√°rio</div>";
            }
            
            // Atualizar invent√°rio visual
            const inventoryGrid = document.getElementById("ship-inventory");
            inventoryGrid.innerHTML = "";
            for (let i = 0; i < player.maxInventory; i++) {
                const slot = document.createElement("div");
                slot.className = "inventory-slot";
                if (i < player.inventory.length) {
                    slot.className += " filled";
                    slot.textContent = player.inventory[i];
                }
                inventoryGrid.appendChild(slot);
            }
        }

        function equipBackpack() {
            const backpackIndex = player.inventory.indexOf("üéí");
            if (backpackIndex !== -1 && !player.backpack) {
                player.inventory.splice(backpackIndex, 1);
                player.backpack = "equipped";
                player.maxInventory = 15;
                missions[3].completed = true; // Equipou mochila
                updateMissions();
                showMessage("üéí Mochila equipada! +5 slots de invent√°rio");
                updateShipInterface();
            } else if (player.backpack) {
                showMessage("‚úÖ Mochila j√° equipada!");
            } else {
                showMessage("‚ùå Voc√™ precisa de uma mochila no invent√°rio!");
            }
        }

        function consumeItem(type) {
            let consumed = false;
            if (type === "food") {
                const foodIndex = player.inventory.findIndex(item => ["üçñ", "ü•î", "üçû"].includes(item));
                if (foodIndex !== -1) {
                    player.inventory.splice(foodIndex, 1);
                    player.hunger = Math.min(100, player.hunger + 30);
                    consumed = true;
                    showMessage("üçñ Comeu e recuperou fome!");
                }
            } else if (type === "water") {
                if (gameState.water > 0) {
                    gameState.water--;
                    player.thirst = Math.min(100, player.thirst + 40);
                    consumed = true;
                    showMessage("üíß Bebeu √°gua e recuperou sede!");
                }
            }
            
            if (!consumed) {
                showMessage("‚ùå Item n√£o dispon√≠vel!");
            } else {
                updateShipInterface();
                updateSurvivalHUD();
            }
        }

        function rest() {
            player.energy = Math.min(100, player.energy + 50);
            showMessage("üò¥ Descansou e recuperou energia!");
            updateShipInterface();
            updateSurvivalHUD();
        }

        // Fun√ß√µes da interface do bunker
        function updateBunkerInterface() {
            document.getElementById("water-count").textContent = gameState.water;
            document.getElementById("potato-seeds").textContent = gameState.potatoSeeds;
            document.getElementById("oxygen-seeds").textContent = gameState.oxygenSeeds;
            
            const farmingGrid = document.getElementById("farming-plots");
            farmingGrid.innerHTML = "";
            gameState.farmingPlots.forEach((plot, index) => {
                const plotDiv = document.createElement("div");
                plotDiv.className = "farming-plot";
                plotDiv.onclick = () => harvestPlot(index);
                
                if (plot === null) {
    
                    plotDiv.textContent = "üü´";
                } else if (plot.type === "potato") {
                    if (plot.ready) {
                        plotDiv.className += " ready";
           
                        plotDiv.textContent = "ü•î";
                    } else {
                        plotDiv.className += " planted";
                        plotDiv.textContent = "üå±";
          
                    }
                } else if (plot.type === "oxygen-plant") {
                    if (plot.ready) {
                        plotDiv.className += " ready";
                   
                        plotDiv.textContent = "üåø";
                    } else {
                        plotDiv.className += " planted";
                        plotDiv.textContent = "üå±";
                    }
                }
                
                farmingGrid.appendChild(plotDiv);
            });
        }

        function plantCrop(cropType) {
            const emptyPlot = gameState.farmingPlots.findIndex(plot => plot === null);
            if (emptyPlot === -1) {
                showMessage("‚ùå N√£o h√° espa√ßo dispon√≠vel!");
                return;
            }
            
            if (cropType === "potato" && gameState.potatoSeeds > 0) {
                gameState.potatoSeeds--;
                gameState.farmingPlots[emptyPlot] = {
                    type: "potato",
                    plantedAt: Date.now(),
                    ready: false
                };
                showMessage("ü•î Batata plantada!");
            } else if (cropType === "oxygen-plant" && gameState.oxygenSeeds > 0) {
                gameState.oxygenSeeds--;
                gameState.farmingPlots[emptyPlot] = {
                    type: "oxygen-plant",
                    plantedAt: Date.now(),
                    ready: false
                };
                showMessage("üåø Planta de O¬≤ plantada!");
            } else {
                showMessage("‚ùå Sementes insuficientes!");
            }
            
            updateBunkerInterface();
        }

        function waterPlants() {
            if (gameState.water < 2) {
                showMessage("‚ùå √Ågua insuficiente! (Precisa de 2)");
                return;
            }
            
            gameState.water -= 2;
            let wateredCount = 0;
            
            gameState.farmingPlots.forEach(plot => {
                if (plot && !plot.ready) {
                    plot.plantedAt -= 30000; // Acelera crescimento
                    wateredCount++;
                }
            });
            if (wateredCount > 0) {
                showMessage(`üíß Regou ${wateredCount} plantas! Crescimento acelerado.`);
            } else {
                showMessage("‚ùå Nenhuma planta para regar!");
            }
            
            updateBunkerInterface();
        }

        function harvestPlot(index) {
            const plot = gameState.farmingPlots[index];
            if (!plot) {
                showMessage("‚ùå Nenhuma planta neste local!");
                return;
            }
            
            if (!plot.ready) {
                showMessage("‚ùå Planta ainda n√£o est√° pronta!");
                return;
            }
            
            if (player.inventory.length >= player.maxInventory) {
                showMessage("‚ùå Invent√°rio cheio!");
                return;
            }
            
            if (plot.type === "potato") {
                player.inventory.push("ü•î");
                gameState.potatoSeeds += 2; // Sementes extras
                missions[2].completed = true;
                // Colheu batata
                updateMissions();
                showMessage("ü•î Colheu batata! +2 sementes extras");
            } else if (plot.type === "oxygen-plant") {
                player.oxygen = Math.min(100, player.oxygen + 15);
                gameState.oxygenSeeds += 1;
                showMessage("üåø Colheu planta de O¬≤! Oxig√™nio restaurado");
            }
            
            gameState.farmingPlots[index] = null;
            updateBunkerInterface();
            updateSurvivalHUD();
        }

        function harvestAll() {
            let harvested = 0;
            gameState.farmingPlots.forEach((plot, index) => {
                if (plot && plot.ready && player.inventory.length < player.maxInventory) {
                    harvestPlot(index);
                    harvested++;
                }
            });
            if (harvested === 0) {
                showMessage("‚ùå Nenhuma planta pronta ou invent√°rio cheio!");
            } else {
                showMessage(`üåæ Colheu ${harvested} plantas!`);
            }
        }

        // Fun√ß√µes da oficina
        function craftItem(type) {
            switch(type) {
                case "medkit":
                    if (gameState.water >= 1 && player.inventory.includes("ü•î")) {
               
                        gameState.water--;
                        player.inventory.splice(player.inventory.indexOf("ü•î"), 1);
                        player.hunger = Math.min(100, player.hunger + 20);
                        player.health = Math.min(100, player.health + 30);
                        showMessage("üíä Kit M√©dico criado e usado!");
                    } else {
                        showMessage("‚ùå Falta √Ågua ou Batata!");
                    }
                    break;
                case "filter":
                    if (player.inventory.includes("üåø") && gameState.water >= 1) {
                        player.inventory.splice(player.inventory.indexOf("üåø"), 1);
                        gameState.water--;
                        player.oxygen = Math.min(100, player.oxygen + 30);
                        showMessage("üåø Filtro de O¬≤ criado e usado!");
                    } else {
                        showMessage("‚ùå Recurso insuficiente!");
                    }
                    break;
                case "solar":
                    if (player.backpack && player.energy < 100) {
                        player.energy = Math.min(100, player.energy + 50);
                        showMessage("‚ö° Painel Solar ativado! Energia restaurada.");
                        missions[4].completed = true; // Reparo da nave
                        updateMissions();
                    } else if (!player.backpack) {
                        showMessage("‚ùå Voc√™ precisa de uma mochila equipada!");
                    } else {
                        showMessage("‚ùå Energia j√° est√° cheia!");
                    }
                    break;
            }
            updateSurvivalHUD();
        }

        // Fun√ß√£o para fechar interfaces
        function closeInterface(interfaceId) {
            document.getElementById(interfaceId).style.display = "none";
        }

        // Sistema de sobreviv√™ncia
        function updateSurvival() {
            const now = Date.now();
            const timeDiff = (now - gameState.lastSurvivalUpdate) / 1000;
            
            if (timeDiff >= 5) { // Atualiza a cada 5 segundos
                player.hunger = Math.max(0, player.hunger - 1);
                player.thirst = Math.max(0, player.thirst - 1.5);
                player.oxygen = Math.max(0, player.oxygen - 0.5);
                player.energy = Math.max(0, player.energy - 0.8);
                gameState.lastSurvivalUpdate = now;
                updateSurvivalHUD();
                
                // Verificar condi√ß√µes cr√≠ticas
                if (player.hunger <= 0 || player.thirst <= 0 || player.oxygen <= 0) {
                    showMessage("üíÄ CR√çTICO! Voc√™ precisa de recursos urgentemente!");
                }
            }
        }

        function updateSurvivalHUD() {
            document.querySelector(".hunger").style.width = player.hunger + "%";
            document.querySelector(".thirst").style.width = player.thirst + "%";
            document.querySelector(".oxygen").style.width = player.oxygen + "%";
            document.querySelector(".energy").style.width = player.energy + "%";
        }

        // Atualizar crescimento das plantas
        function updatePlants() {
            const now = Date.now();
            gameState.farmingPlots.forEach(plot => {
                if (plot && !plot.ready) {
                    const growthTime = (now - plot.plantedAt) / 1000;
                    if (growthTime >= 60) { // 1 minuto para crescer
                      
                        plot.ready = true;
                    }
                }
            });
        }

        // Sistema de Salvamento
        function saveGame() {
            const saveData = {
                player,
                gameState,
                missions,
                timeOfDay,
                enemies,
                currentChunkData: { // Salvar apenas o necess√°rio para regenerar
                    chunkX: player.chunkX,
                    chunkY: player.chunkY,
                    biomeName: currentChunkData.biome.name 
                }
            };
            localStorage.setItem("zyroSave", JSON.stringify(saveData));
        }

        function loadGame() {
            const saved = localStorage.getItem("zyroSave");
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    Object.assign(player, data.player);
                    Object.assign(gameState, data.gameState);
                    missions = data.missions || missions;
                    timeOfDay = data.timeOfDay || 12;
                    
                    // Carrega o chunk correto e seus dados procedurais
                    loadChunk(data.player.chunkX, data.player.chunkY);

                    showMessage("üíæ Progresso carregado!");
                    updateMissions();
                    updateSurvivalHUD();
                } catch (e) {
                    console.log("Erro ao carregar save:", e);
                    // Se falhar, carrega o chunk inicial
                    loadChunk(0, 0); 
                }
            } else {
                // Se n√£o houver save, carrega o chunk inicial
                 loadChunk(0, 0); 
            }
        }

        // Fun√ß√µes auxiliares
        function showMessage(text) {
            const existing = document.querySelector(".message");
            if (existing) existing.remove();
            
            const message = document.createElement("div");
            message.className = "message";
            message.textContent = text;
            message.style.cssText = `
                position: fixed;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.9);
                color: #00bfff;
                padding: 10px 20px;
                border-radius: 10px;
                border: 2px solid #00bfff;
                font-weight: bold;
                z-index: 1000;
                animation: fadeMessage 3s ease-in-out forwards;
            `;
            
            document.body.appendChild(message);
            setTimeout(() => message.remove(), 3000);
        }

        function updateHUD() {
            const nearestPOI = findNearestPOI();
            if (nearestPOI) {
                document.getElementById("hud").textContent = `Pr√≥ximo: ${nearestPOI.name}`;
            } else {
                 document.getElementById("hud").textContent = `√Årea: ${currentChunkData.biome.name} (${player.chunkX}, ${player.chunkY})`;
            }
        }

        function findNearestPOI() {
            let nearest = null;
            let minDistance = 100;
            
            pointsOfInterest.forEach(poi => {
                let dx = player.x - poi.x;
                let dy = player.y - poi.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
           
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = poi;
                }
            });
            return nearest;
        }

        // Loop principal
        function loop() {
            // Movimenta√ß√£o
            if (joy.x !== 0 || joy.y !== 0) {
                player.x += joy.x * player.speed;
                player.y += joy.y * player.speed;
                
                // Consumir energia ao se mover
                player.energy = Math.max(0, player.energy - 0.01);
            }

            // --- L√ìGICA DE TRANSI√á√ÉO DE CHUNK ---
            let movedChunk = false;
            
            if (player.x < 0) {
                player.chunkX--;
                player.x += CHUNK_SIZE;
                movedChunk = true;
            } else if (player.x > CHUNK_SIZE) {
                player.chunkX++;
                player.x -= CHUNK_SIZE;
                movedChunk = true;
            }

            if (player.y < 0) {
                player.chunkY--;
                player.y += CHUNK_SIZE;
                movedChunk = true;
            } else if (player.y > CHUNK_SIZE) {
                player.chunkY++;
                player.y -= CHUNK_SIZE;
                movedChunk = true;
            }
            
            if (movedChunk) {
                loadChunk(player.chunkX, player.chunkY);
            }
            // --- FIM L√ìGICA DE TRANSI√á√ÉO DE CHUNK ---


            // C√¢mera (Atualizada para usar CHUNK_SIZE)
            cam.x = Math.max(0, Math.min(CHUNK_SIZE - canvas.width, player.x - canvas.width / 2));
            cam.y = Math.max(0, Math.min(CHUNK_SIZE - canvas.height, player.y - canvas.height / 2));

            // Atualizar sistemas
            updateSurvival();
            updatePlants();
            updateDayCycle();
            saveGame();
            // Limpar tela
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Desenhar mundo com offset da c√¢mera
            ctx.save();
            ctx.translate(-cam.x, -cam.y);

            // Desenhar fundo
            drawBackground();
            // Desenhar pontos de interesse
            drawPointsOfInterest();
            // Desenhar inimigos
            drawEnemies();
            // Desenhar player
            drawPlayer();

            ctx.restore();
            updateHUD();
            requestAnimationFrame(loop);
        }

        function drawBackground() {
            // Fundo do planeta usando as cores do bioma atual
            const gradient = ctx.createRadialGradient(CHUNK_SIZE/2, CHUNK_SIZE/2, 0, CHUNK_SIZE/2, CHUNK_SIZE/2, CHUNK_SIZE);
            gradient.addColorStop(0, currentChunkData.biome.backgroundGradient[0]);
            gradient.addColorStop(1, currentChunkData.biome.backgroundGradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CHUNK_SIZE, CHUNK_SIZE);
            
            // Grid de refer√™ncia
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 1;
            for (let x = 0; x <= CHUNK_SIZE; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CHUNK_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= CHUNK_SIZE; y += 100) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CHUNK_SIZE, y);
                ctx.stroke();
            }
            
            // Caminhos conectando os pontos (apenas no chunk inicial)
            if (player.chunkX === 0 && player.chunkY === 0) {
                ctx.strokeStyle = "rgba(139, 115, 85, 0.6)";
                ctx.lineWidth = 8;
                ctx.beginPath();
                // Conectar nave com outros pontos
                ctx.moveTo(600, 400);
                ctx.lineTo(200, 600); // Para bunker
                ctx.moveTo(600, 400);
                ctx.lineTo(600, 700); // Para oficina
                // Desenha os caminhos
                ctx.stroke();
            }
        }

        function drawPointsOfInterest() {
            pointsOfInterest.forEach(poi => {
                // √Årea de intera√ß√£o
                let dx = player.x - poi.x;
                let dy = player.y - poi.y;
               
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
                    ctx.lineWidth = 3;
       
                    ctx.beginPath();
                    ctx.arc(poi.x, poi.y, 80, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
         
                // Base do ponto
                ctx.fillStyle = poi.color;
                ctx.beginPath();
                ctx.arc(poi.x, poi.y, 40, 0, Math.PI * 2);
                ctx.fill();
                
  
                // Borda
                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 
                // √çcone
                ctx.font = "30px Arial";
                ctx.fillStyle = "#ffffff";
                ctx.textAlign = "center";
                ctx.fillText(poi.icon, poi.x, poi.y + 10);
                // Nome
                ctx.font = "14px Arial";
                ctx.fillStyle = "#ffffff";
                ctx.fillText(poi.name, poi.x, poi.y + 60);
                
                // Efeito de pulso para pontos pr√≥ximos
                if (distance < 100) {
                    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(poi.x, poi.y, 50, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        function drawPlayer() {
            // Sombra
            ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
            ctx.beginPath();
            ctx.ellipse(player.x, player.y + player.r + 5, player.r * 0.8, player.r * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Corpo do astronauta
            ctx.fillStyle = "#1e40af";
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
            ctx.fill();
            
            // Borda do traje
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 4;
            ctx.stroke();

            // Visor do capacete
            ctx.fillStyle = "rgba(0, 191, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(player.x, player.y - 3, player.r * 0.6, 0, Math.PI * 2);
            ctx.fill();
            // Reflexo no visor
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath();
            ctx.arc(player.x - 8, player.y - 8, player.r * 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Mochila se equipada
            if (player.backpack) {
                ctx.fillStyle = "#8b4513";
                ctx.fillRect(player.x - 15, player.y + 10, 30, 20);
                ctx.strokeStyle = "#654321";
                ctx.lineWidth = 2;
                ctx.strokeRect(player.x - 15, player.y + 10, 30, 20);
            }

            // Indicador de dire√ß√£o
            if (joy.x !== 0 || joy.y !== 0) {
                ctx.strokeStyle = "#00ff00";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x + joy.x * 40, player.y + joy.y * 40);
                ctx.stroke();
                // Ponta da seta
                ctx.fillStyle = "#00ff00";
                ctx.beginPath();
                ctx.arc(player.x + joy.x * 40, player.y + joy.y * 40, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Indicador de status cr√≠tico
            if (player.hunger <= 20 || player.thirst <= 20 || player.oxygen <= 20) {
                const flash = Math.sin(Date.now() / 200) > 0;
                if (flash) {
                    ctx.strokeStyle = "#ff0000";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.r + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Barra de vida se ferido
            if (player.health < 100) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(player.x - 30, player.y - 45, 60, 8);
                ctx.fillStyle = "#ff0000";
                ctx.fillRect(player.x - 28, player.y - 43, (player.health / 100) * 56, 4);
            }
        }

        // Inicializa√ß√£o
        loadGame();
        updateMissions();
        showMessage("üöÄ Bem-vindo ao ZYRO v0.3! Mapa Infinito Carregado!");
        loop();

        // Preven√ß√£o de scroll
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        console.log("üåç ZYRO v0.3 - Sistema de Chunking/Biomas Carregado!");
        </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98ac29bfe648f1ff',t:'MTc1OTgyNzE1NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
    </html>
